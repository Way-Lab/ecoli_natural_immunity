#!/usr/bin/env python3
"""
Generate Peptide Region Alignments with RS218 Reference

This script takes a MAFFT-aligned multi-FASTA file and extracts specific peptide
regions, displaying them with RS218 as the reference strain.
Matching residues are shown as dots for easy visualization of differences.

Usage:
    python generate_peptide_alignments_with_references.py <aligned_fasta> <output_file>

Example:
    python generate_peptide_alignments_with_references.py mafft_aligned_authentic.fasta peptide_alignment_authentic.txt

Author: Generated by Claude Code
Date: October 30, 2024
"""

import sys
from Bio import SeqIO


# Define peptide sequences - all referenced to EcN
PEPTIDES = {
    'Peptide_1': 'WSQYHDTGFINNNGPTHEN',
    'Peptide_2': 'GRMPYKGSVENGAYKA',
    'Peptide_2b': 'GRMPYKGDNINGAYKA',
    'Peptide_3a': 'KSNVYGKN',
    'Peptide_3b': 'KANVPGGASFKD',
    'Peptide_4': 'TNNIGDAHTIGTRPDNGM',
}

# Desired strain order for output (EcN first, then RS218 reference, then others)
STRAIN_ORDER = ['EcN', 'RS218', 'UTI189', 'SCB12', 'SCB29', 'SCB61', 'SCB34', 'SCB58', 'SCB37', 'SCB60']


def get_strain_name(record):
    """
    Extract a clean strain name from a SeqRecord.

    Args:
        record: BioPython SeqRecord object

    Returns:
        str: Clean strain name (e.g., 'RS218', 'EcN', 'O157:H7')
    """
    desc = record.description.lower()
    seq_id = record.id

    # Check for specific strain identifiers in order of priority
    if 'rs218' in desc or seq_id == 'RS218':
        return 'RS218'
    elif seq_id == 'CFT073' or 'cft073' in desc:
        return 'CFT073'
    elif seq_id == 'EcN' or 'nissle' in desc or 'ecn' in desc:
        return 'EcN'
    elif 'eco57' in desc or ('o157' in desc and 'p0a911' in seq_id.lower()):
        return 'O157:H7'
    elif 'sakai' in desc or ('o157' in desc and 'np_309068' in seq_id.lower()):
        return 'O157:H7_Sakai'
    elif 'ec958' in desc:
        return 'EC958'
    elif 'uti189' in desc:
        return 'UTI189'
    elif 'dh5' in desc:
        return 'DH5alpha'
    elif 'k-12' in desc or 'mg1655' in desc:
        return 'K-12'
    elif 'scb12' in desc:
        return 'SCB12'
    elif 'scb29' in desc:
        return 'SCB29'
    elif 'scb34' in desc:
        return 'SCB34'
    elif 'scb37' in desc:
        return 'SCB37'
    elif 'scb58' in desc:
        return 'SCB58'
    elif 'scb60' in desc or seq_id == 'SCB60':
        return 'SCB60'
    elif 'scb61' in desc or seq_id == 'SCB61':
        return 'SCB61'
    else:
        # Default to first 15 characters of ID
        return seq_id[:15]


def mask_matching_residues(ref_seq, query_seq):
    """
    Replace matching residues with dots to highlight differences.

    Args:
        ref_seq: Reference sequence string
        query_seq: Query sequence string (same length as ref_seq)

    Returns:
        str: Query sequence with matches replaced by '.'
    """
    result = []
    for r, q in zip(ref_seq, query_seq):
        if r == q:
            result.append('.')
        else:
            result.append(q)
    return ''.join(result)


def map_ungapped_to_gapped(aligned_seq, ungapped_start, ungapped_end):
    """
    Map ungapped sequence positions to gapped alignment positions.

    When searching for a peptide in an ungapped sequence, we need to find
    where that region appears in the gapped alignment.

    Args:
        aligned_seq: Aligned sequence string (may contain '-' gaps)
        ungapped_start: Start position in ungapped sequence (0-based)
        ungapped_end: End position in ungapped sequence (0-based, exclusive)

    Returns:
        tuple: (gapped_start, gapped_end) positions in aligned sequence
    """
    ungapped_pos = 0
    gapped_start = None
    gapped_end = None

    for i, aa in enumerate(aligned_seq):
        if aa != '-':  # Only count non-gap characters
            if ungapped_pos == ungapped_start:
                gapped_start = i
            if ungapped_pos == ungapped_end:
                gapped_end = i
                break
            ungapped_pos += 1

    return gapped_start, gapped_end


def order_sequences(sequence_data, strain_order):
    """
    Order sequences according to a predefined strain order.

    Filters sequences to only include strains in the desired order list.

    Args:
        sequence_data: List of tuples (strain_name, peptide_sequence)
        strain_order: List of strain names in desired order

    Returns:
        List of tuples (strain_name, peptide_sequence) in specified order
    """
    # Create a dictionary for quick lookup
    seq_dict = {strain: seq for strain, seq in sequence_data}

    # Build result list in the specified order, only including strains that exist
    result = []
    for strain in strain_order:
        if strain in seq_dict:
            result.append((strain, seq_dict[strain]))

    return result


def generate_peptide_alignments(input_fasta, output_file):
    """
    Main function to generate peptide region alignments.

    Args:
        input_fasta: Path to MAFFT-aligned FASTA file
        output_file: Path to output text file
    """
    # Read sequences
    sequences = list(SeqIO.parse(input_fasta, 'fasta'))

    print("="*100)
    print("PEPTIDE ALIGNMENT WITH RS218 REFERENCE")
    print("="*100)
    print(f"\nTotal sequences: {len(sequences)}")
    print(f"Input file: {input_fasta}")
    print(f"Output file: {output_file}")
    print()

    # Find RS218 sequence
    rs218_record = None
    for record in sequences:
        strain = get_strain_name(record)
        if strain == 'RS218':
            rs218_record = record
            break

    if not rs218_record:
        raise ValueError("RS218 sequence not found in alignment!")

    rs218_aligned = str(rs218_record.seq)
    rs218_ungapped = rs218_aligned.replace('-', '')

    print(f"Using RS218 reference: {get_strain_name(rs218_record)}")

    # Find all peptide positions in RS218 ungapped sequence
    rs218_positions = {}
    ecn_positions = {}
    peptides_not_in_rs218 = []

    for pep_name, pep_seq in PEPTIDES.items():
        pos = rs218_ungapped.find(pep_seq)
        if pos != -1:
            rs218_positions[pep_name] = {
                'start': pos,
                'end': pos + len(pep_seq),
                'sequence': pep_seq
            }
            print(f"  Found {pep_name} at position {pos} in RS218")
        else:
            print(f"  {pep_name} not found in RS218 - will search in EcN")
            peptides_not_in_rs218.append(pep_name)

    # For peptides not in RS218, find them in EcN
    ecn_record = None
    if peptides_not_in_rs218:
        for record in sequences:
            strain = get_strain_name(record)
            if strain == 'EcN':
                ecn_record = record
                break

        if ecn_record:
            ecn_aligned = str(ecn_record.seq)
            ecn_ungapped = ecn_aligned.replace('-', '')
            print(f"\nSearching EcN for peptides not in RS218:")

            for pep_name in peptides_not_in_rs218:
                pep_seq = PEPTIDES[pep_name]
                pos = ecn_ungapped.find(pep_seq)
                if pos != -1:
                    ecn_positions[pep_name] = {
                        'start': pos,
                        'end': pos + len(pep_seq),
                        'sequence': pep_seq
                    }
                    print(f"  Found {pep_name} at position {pos} in EcN")
                else:
                    print(f"  WARNING: {pep_name} not found in EcN either!")

    # Create output file
    with open(output_file, 'w') as out:
        # Write header
        out.write("="*100 + "\n")
        out.write("PEPTIDE REGIONS - RS218 REFERENCE\n")
        out.write("="*100 + "\n\n")
        out.write(f"Total sequences: {len(sequences)}\n")
        out.write(f"Alignment: MAFFT\n")
        out.write(f"Format: '.' = match to reference, letter = difference, '-' = gap\n")
        out.write(f"Sample order: {', '.join(STRAIN_ORDER)}\n\n")

        # Process each peptide in order
        peptide_names = ['Peptide_1', 'Peptide_2', 'Peptide_2b', 'Peptide_3a', 'Peptide_3b', 'Peptide_4']

        for pep_name in peptide_names:
            # Check if peptide is in RS218 or EcN
            if pep_name in rs218_positions:
                pep_info = rs218_positions[pep_name]
                ref_aligned = rs218_aligned
                ref_name = 'RS218'
                ref_note = ''
            elif pep_name in ecn_positions:
                pep_info = ecn_positions[pep_name]
                ref_aligned = ecn_aligned
                ref_name = 'EcN'
                ref_note = ' (peptide found in EcN, not in RS218)'
            else:
                continue

            # Map ungapped positions to gapped alignment positions
            start, end = map_ungapped_to_gapped(
                ref_aligned,
                pep_info['start'],
                pep_info['end']
            )

            if start is None or end is None:
                print(f"  WARNING: Could not map {pep_name} to gapped alignment")
                continue

            # Extract the peptide region from aligned reference sequence
            ref_peptide = ref_aligned[start:end]

            # Collect all sequences
            all_sequences = []
            for record in sequences:
                strain = get_strain_name(record)
                aligned_seq = str(record.seq)
                peptide_region = aligned_seq[start:end]
                all_sequences.append((strain, peptide_region))

            # Order sequences according to STRAIN_ORDER
            ordered = order_sequences(all_sequences, STRAIN_ORDER)

            # Write to file
            out.write("="*100 + "\n")
            out.write(f"{pep_name}: {pep_info['sequence']}{ref_note}\n")
            out.write("="*100 + "\n")
            out.write(f"{'Strain':<15} {ref_peptide}\n")
            out.write(f"{'-'*15} {'-'*len(ref_peptide)}\n")

            # Print to console
            print()
            print("="*100)
            print(f"{pep_name}: {pep_info['sequence']}{ref_note}")
            print("="*100)
            print(f"{'Strain':<15} {ref_peptide}")
            print(f"{'-'*15} {'-'*len(ref_peptide)}")

            # Write ordered sequences
            for strain, peptide_seq in ordered:
                # Show RS218 first in the list, but compare to the actual reference for the peptide
                if strain == ref_name:
                    # Don't mask the reference itself
                    out.write(f"{strain:<15} {peptide_seq}\n")
                    print(f"{strain:<15} {peptide_seq}")
                else:
                    masked_region = mask_matching_residues(ref_peptide, peptide_seq)
                    out.write(f"{strain:<15} {masked_region}\n")
                    print(f"{strain:<15} {masked_region}")

            out.write("\n")

        out.write("="*100 + "\n")

    print()
    print("="*100)
    print(f"\nComplete alignment saved to: {output_file}")


def main():
    """Main entry point for the script."""
    if len(sys.argv) < 2:
        print("Usage: python generate_peptide_alignments_with_references.py <aligned_fasta> [output_file]")
        print("\nExample:")
        print("  python generate_peptide_alignments_with_references.py mafft_aligned_authentic.fasta peptide_alignment.txt")
        sys.exit(1)

    input_fasta = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else 'peptide_alignment_output.txt'

    try:
        generate_peptide_alignments(input_fasta, output_file)
    except Exception as e:
        print(f"\nERROR: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
